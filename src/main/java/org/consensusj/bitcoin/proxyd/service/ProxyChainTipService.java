package org.consensusj.bitcoin.proxyd.service;

import com.msgilligan.bitcoinj.json.pojo.ChainTip;
import com.msgilligan.bitcoinj.rpc.BitcoinClient;
import io.reactivex.rxjava3.annotations.NonNull;
import io.reactivex.rxjava3.core.Maybe;
import io.reactivex.rxjava3.core.Observable;
import io.reactivex.rxjava3.core.Observer;
import io.reactivex.rxjava3.core.Single;
import io.reactivex.rxjava3.disposables.Disposable;
import io.reactivex.rxjava3.internal.operators.observable.ObservableInterval;
import io.reactivex.rxjava3.subjects.BehaviorSubject;
import io.reactivex.rxjava3.subjects.Subject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.inject.Singleton;
import java.io.Closeable;
import java.io.IOError;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

/**
 * An observable source of ChainTip objects generated by polling a Bitcoin JSON-RPC server
 */
@Singleton
public class ProxyChainTipService extends Observable<ChainTip> implements Closeable  {
    private static final Logger log = LoggerFactory.getLogger(ProxyChainTipService.class);
    private final Observable<Long> interval;
    private Disposable intervalSubscription;
    // BehaviorProcessor will remember the last block received and pass it to new subscribers.
    private final Subject<ChainTip> chainTipSubject = BehaviorSubject.create();

    private final BitcoinClient jsonRpc;

    public ProxyChainTipService(BitcoinClient client) {
        jsonRpc = client;
        this.interval = ObservableInterval.interval(1, TimeUnit.MINUTES);
    }


    @Override
    protected void subscribeActual(@NonNull Observer<? super ChainTip> observer) {
        start();
        chainTipSubject.subscribe(observer);
    }

    @Override
    public void close() {
        intervalSubscription.dispose();
    }

    /**
     * Subscribe to the interval, using it to make polling calls (via flatMapMaybe) to jsonRpc
     * to get the current {@link ChainTip}.
     */
    private synchronized void start() {
        if (intervalSubscription == null) {
            intervalSubscription = interval
                    .flatMapMaybe(t -> this.currentChainTipMaybe())
                    .doOnNext(tip -> log.info("blockheight, blockhash = {}, {}", tip.getHeight(), tip.getHash()))
                    .distinctUntilChanged(ChainTip::getHash)
                    .doOnNext(tip -> log.info("** NEW ** blockheight, blockhash = {}, {}", tip.getHeight(), tip.getHash()))
                    .subscribe(chainTipSubject::onNext, chainTipSubject::onError, chainTipSubject::onComplete);
        }
    }

    /**
     * Wrap a block chainTip in a Single.
     * @return A Single for the block height
     */
    private Single<ChainTip> currentChainTip() {
        return Single.defer(() -> Single.fromCompletionStage(chainTip()));
    }

    /**
     * Retrieve the first ChainTip from the list returned by the
     * standard RPC `getchaintips`
     *
     * @return The current chain tip
     */
    private CompletableFuture<ChainTip> chainTip() {
        return jsonRpc.supplyAsync(jsonRpc::getChainTips).thenApply(l -> l.get(0));
    }

    /**
     * Get ChainTip, but swallowing IOExceptions
     *
     * @return A Maybe that is empty if an {@link IOError} occurred
     */
    private Maybe<ChainTip> currentChainTipMaybe() {
        return currentChainTip()
                .toMaybe()
                .doOnError(t -> log.error("Exception in currentChainTipMaybe", t))
                .onErrorComplete(t -> t instanceof IOError);    // Empty completion if IOError
    }

}
